<!doctype html>
<html>
	<head>

		<title>Tema 10</title>
		<link rel="shortcut icon" href="images/favicon.ico" />

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img src="images/comillas-logo.png" width="50%" />
					<p>
						Programación de Aplicaciones Telemáticas
					</p>
				</section>
				<section>
					<h2>Tema 10: Acceso a base de datos relacionales (JDBC)</h2>
				</section>
				<section>
					<!-- Inicio de lo añadido en la sesion 3 -->
					<section>
						<h2>Agenda</h2>
						<h3>Sessión 3</h3>
						<ul>
							<li>JDBC Templates</li>
							<li>SQL Joins</li>
						</ul>
					</section>
				</section>
				<section>
					<h2>Sessión 3</h2>
				</section>
				<section>
					<h2>JDBC Templates</h2>
				</section>
				
					<section>
						<h2>Introduccion</h2>
						<ul>
							<li>Generalmente el uso y explotación de bases de datos SQL en Java lo realizamos a través de herramientas de mapeo ORM tales como Hibernate o Apache OpenJPA</li>
							<li>Spring Data JPA proporciona su propia capa de abstracción</li>
							<li>En algunos escenarios no es una buena opción o incluso es inviable el uso de Hibernate y similares</li>
						</ul>
					</section>
					<section>
						<h2>Escenarios</h2>
						<ul>
							<li>Bases de datos no normalizadas ya existentes, cuya estructura no podemos modificar , y que resultan muy complejas de modelar con entidades</li>
							<li>Tenemos que utilizar directamente SQL para aprovechar las funcionalidades proporcionadas por la propia de base datos y/o optimizar al máximo el rendimiento</li>
							<li>Capas de persistencia que se basan en el uso intensivo de procedimientos almacenados</li>
						</ul>
					</section>
					<section>
						<h2>Principios</h2>
						<ul>
							<li>nos permitirá precisamente centrarnos en el código que importa -el sql y los mapeos</li>
							<li>No tendremos que abrir conexiones, devolverlas, o gestionar manualmente las transacciones</li>
						</ul>
					</section>
					<section>
						<h2>Configuración</h2>
						<img src="images/config1.png" />
					</section>
					<section>
						<h2>Configuración</h2>
						<img src="images/config2.png" />
					</section>

					<section>
						<h2>Ejemplo: SELECT</h2>
						<img src="images/example-select.png" />
					</section>

					<section>
						<h2>Ejemplo: INSERT</h2>
						<img src="images/example-insert.png" />
					</section>

					<section>
						<h2>Ejemplo: PARAMETROS</h2>
						<img src="images/example-params.png" />
					</section>

					<section>
						<h2>Ejemplo: MAPPING</h2>
						<img src="images/example-mapping.png" />
						<img src="images/example-mapping2.png" />
					</section>
				<section>
					<h2>SQL Joins</h2>
				</section>
				<section>
					<h2>Tipos</h2>
					<img src="images/joins.png" width="80%"/>	
				</section>
				<section>
					<h2>Tipos</h2>
					<ul>
						<li><b>Inner Join.</b> El Join de “toda la vida”. El join per defecto que se aplica cuando no indicamos otra cosa al hacer la consulta. Devuelve sólo aquellas filas donde haya un “match”, es decir, las filas donde el valor del campo de la tabla A que se utiliza para hacer el Join coincida con el valor del campo correspondiente en la tabla B.  Ejemplo: devolver todos los productos para los que haya como mínimo un pedido en los últimos días (el inner join enlazará el campo producto en la tabla Pedido con la clave primaria de ese producto en la tabla Producto)</li>
					</ul>	
				</section>
				<section>
					<h2>Tipos</h2>
					<ul>
						<li><b>Left outer Join.</b> Cuando quieres todas las filas para las que haya match pero también aquellas de la Tabla A que no hagan match. Siguiendo el ejemplo anterior, si quieres listar todos los productos con datos de sus pedidos pero mostrando también aquellos productos para lo que no tengas todavía un pedido, la solución sería hacer una Left Outer join entre Producto y Pedido.</li>
					</ul>	
				</section>
				<section>
					<h2>Tipos</h2>
					<ul>
						<li><b>Right outer Join.</b>  Exactamente lo mismo pero a la inversa, cuando quieres listar las filas de la tabla B aunque no estén relacionadas con ninguna fila de la tabla A. Es un operador un poco redundante ya que se podría cambiar simplemente el orden de las  tablas en el Join y utilizar un left outer para conseguir el mismo efecto. No obstante, y como parte de Joins múltiples, es útil tener los dos para un mejor comprensión de la consulta</li>
					</ul>	
				</section>
				<section>
					<h2>Tipos</h2>
					<ul>
						<li><b>Full outer join.</b> Es como la suma de las dos anteriores. Queremos tanto las filas de la A como las de B, tanto si hay match como si no (evidentemente cuando haya match la consulta devolverá todos los campos de A y B que hayamos indicado, cuando no, la consulta devolverá sólo los campos de A o B)</li>
					</ul>	
				</section>
				<section>
					<h2>Tipos</h2>
					<img src="images/jokejoin.png" width="50%"/>	
				</section>
				
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
			Reveal.configure(
				{ showNotes: true },
				{ showNotes: 'separate-page' },
				{ pdfMaxPagesPerSlide: 1 }
			);
		</script>
	</body>
</html>
